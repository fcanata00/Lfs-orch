#!/usr/bin/env bash
#
# porg - Orquestrador Porg (versão aprimorada)
# Recursos adicionais: flock lockfile, checkpoints/resume, search, info, graph (ASCII), status, history, repair
#
set -euo pipefail
IFS=$'\n\t'

# ------------------ Config e paths ------------------
PORG_CONF="${PORG_CONF:-/etc/porg/porg.conf}"
[ -f "$PORG_CONF" ] && source "$PORG_CONF"

LIBDIR="${LIBDIR:-/usr/lib/porg}"
BUILDER="${BUILDER:-${LIBDIR}/porg_builder.sh}"
REMOVER="${REMOVER:-${LIBDIR}/porg_remove.sh}"
UPGRADER="${UPGRADER:-${LIBDIR}/porg_upgrade.sh}"
RESOLVER="${RESOLVER:-${LIBDIR}/porg_resolve.sh}"
AUDITOR="${AUDITOR:-${LIBDIR}/porg_audit.sh}"
DEPS_PY="${DEPS_PY:-${LIBDIR}/porg_deps.py}"
DB_SCRIPT="${DB_SCRIPT:-${LIBDIR}/porg_db.sh}"
LOGGER_SCRIPT="${LOGGER_SCRIPT:-${LIBDIR}/porg_logger.sh}"

WORKDIR="${WORKDIR:-/var/tmp/porg}"
LOGDIR="${LOGDIR:-/var/log/porg}"
REPORT_DIR="${REPORT_DIR:-${LOGDIR}}"
STATE_DIR="${STATE_DIR:-/var/lib/porg/state}"
PORTS_DIR="${PORTS_DIR:-/usr/ports}"
LOCKFILE="${LOCKFILE:-/var/lock/porg.lock}"
LOCK_TIMEOUT="${LOCK_TIMEOUT:-30}"

mkdir -p "$WORKDIR" "$LOGDIR" "$REPORT_DIR" "$STATE_DIR" "$(dirname "$LOCKFILE")"

# ------------------ Logger (fallback) ------------------
if [ -f "$LOGGER_SCRIPT" ]; then
  # shellcheck disable=SC1090
  source "$LOGGER_SCRIPT" || true
else
  log_info(){ printf "%s [INFO] %s\n" "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "$*"; }
  log_warn(){ printf "%s [WARN] %s\n" "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "$*" >&2; }
  log_error(){ printf "%s [ERROR] %s\n" "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "$*" >&2; }
fi

_have(){ command -v "$1" >/dev/null 2>&1; }
_timestamp(){ date -u +%Y%m%dT%H%M%SZ; }
_die(){ log_error "$*"; exit 2; }

# ------------------ Locking (flock) ------------------
_acquire_lock(){
  exec 200>"$LOCKFILE"
  if _have flock; then
    flock -n 200 || { log_warn "Another porg instance is running. If stale, remove $LOCKFILE"; exit 1; }
  else
    # naive lock
    if [ -e "$LOCKFILE" ]; then
      pid=$(cat "$LOCKFILE" 2>/dev/null || echo "")
      if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
        log_warn "Another porg instance ($pid) is running. Exit."
        exit 1
      else
        log_warn "Stale lockfile found; removing."
        rm -f "$LOCKFILE"
      fi
    fi
    echo $$ > "$LOCKFILE"
    # register a trap to remove
    trap '_release_lock' EXIT
  fi
}
_release_lock(){
  if _have flock; then
    flock -u 200 2>/dev/null || true
  fi
  [ -f "$LOCKFILE" ] && rm -f "$LOCKFILE" || true
}

# ------------------ State (checkpoint/resume) ------------------
# State files per package: $STATE_DIR/<pkg>.state (JSON)
save_state(){
  local pkg="$1"; local phase="$2"; local extra="${3:-}"
  mkdir -p "$STATE_DIR"
  cat > "${STATE_DIR}/${pkg}.state" <<JSON
{"package":"${pkg}","phase":"${phase}","extra":"${extra}","ts":"$(_timestamp)"}
JSON
}
load_state(){
  local pkg="$1"
  if [ -f "${STATE_DIR}/${pkg}.state" ]; then
    cat "${STATE_DIR}/${pkg}.state"
  else
    echo "{}"
  fi
}
clear_state(){
  local pkg="$1"
  [ -f "${STATE_DIR}/${pkg}.state" ] && rm -f "${STATE_DIR}/${pkg}.state"
}
list_states(){
  ls -1 "$STATE_DIR"/*.state 2>/dev/null || true
}

# ------------------ Helpers: metafile parsing, search, info ------------------
# try to find metafile by package name under /usr/ports
find_metafile_for_pkg(){
  local pkg="$1"
  # search for a yaml file with package name in filename or with name field inside
  if [ -d "$PORTS_DIR" ]; then
    # fast filename search
    local f
    f=$(find "$PORTS_DIR" -type f -iname "*${pkg}*.ya*ml" -print -quit 2>/dev/null || true)
    if [ -n "$f" ]; then
      echo "$f" && return 0
    fi
    # fallback: scan yaml content
    if _have python3; then
      find "$PORTS_DIR" -type f -iname '*.ya*ml' -print0 2>/dev/null | xargs -0 -n1 -I{} python3 - <<PY 2>/dev/null
import sys,yaml,json
p=sys.argv[1]
try:
  d=yaml.safe_load(open(p,'r',encoding='utf-8')) or {}
  name=d.get('name') or d.get('pkg') or ''
  if name and "$pkg" in name:
    print(p)
    sys.exit(0)
except Exception:
  pass
PY
"$f"
    fi
  fi
  return 1
}

# search for packages (simple)
cmd_search(){
  local term="$1"
  if [ -z "$term" ]; then _die "Use: porg --search <termo>"; fi
  log_stage "Searching for: $term"
  # prefer python yaml parse if available for nicer output
  if _have python3; then
    python3 - <<PY
import os,sys,fnmatch
ports_dir="${PORTS_DIR}"
term="${term}".lower()
for root,dirs,files in os.walk(ports_dir):
    for fn in files:
        if fn.lower().endswith(('.yml','.yaml')):
            p=os.path.join(root,fn)
            try:
                import yaml
                d=yaml.safe_load(open(p,'r',encoding='utf-8')) or {}
                name=d.get('name') or fn.rsplit('.',1)[0]
                desc=d.get('description') or d.get('summary') or ''
                if term in name.lower() or term in str(desc).lower():
                    print(f"{name}  - {desc}  ({p})")
            except Exception:
                # fallback simple grep
                try:
                    txt=open(p,'r',encoding='utf-8').read().lower()
                    if term in txt:
                        print(f"{fn.rsplit('.',1)[0]}  - (match in {p})")
                except:
                    pass
            except BaseException:
                pass
PY
  else
    grep -RIl --exclude-dir=.git --exclude='*.lock' --include='*.ya*ml' -- "${term}" "${PORTS_DIR}" 2>/dev/null | sed -n 's#.*/##;s/\..*$//p'
  fi
}

# info about program
cmd_info(){
  local pkg="$1"
  if [ -z "$pkg" ]; then _die "Use: porg --info <pkg>"; fi
  log_stage "Info for: $pkg"
  local mf
  mf=$(find_metafile_for_pkg "$pkg" || true)
  if [ -n "$mf" ]; then
    if _have python3; then
      python3 - <<PY
import yaml,json,sys
p=sys.argv[1]
try:
  d=yaml.safe_load(open(p,'r',encoding='utf-8')) or {}
except Exception:
  print("Unable to parse metafile",p)
  sys.exit(1)
print("Metafile:",p)
print("Name:",d.get('name'))
print("Version:",d.get('version') or d.get('ver'))
print("Summary:",d.get('description') or d.get('summary') or '')
print("Category/path:",p)
print("Dependencies:",d.get('dependencies') or d.get('deps') or [])
print("Source(s):",d.get('source_url') or d.get('source_urls') or d.get('sources') or '')
print("License:",d.get('license') or '')
PY
    else
      awk 'BEGIN{FS=": "}/^name:|^version:|^description:|^summary:|^license:/{print}' "$mf"
      echo "Metafile: $mf"
    fi
  else
    log_warn "Metafile not found for $pkg under $PORTS_DIR"
  fi
  # installed status via DB
  if [ -x "$DB_SCRIPT" ]; then
    "$DB_SCRIPT" status "$pkg" || true
  else
    log_info "DB script not available to show installed state"
  fi
  # state file (checkpoint)
  if [ -f "${STATE_DIR}/${pkg}.state" ]; then
    echo "Resume state:"
    cat "${STATE_DIR}/${pkg}.state"
  fi
}

# ------------------ Graph ASCII (--graph) ------------------
# We will try to use deps.py graph if available; else fallback to parsing metafile dependencies recursively
graph_ascii_recursive(){
  local pkg="$1"
  local depth="${2:-0}"
  local prefix="${3:-}"
  local visited_file="$4"
  # protect cycles
  if grep -qx "$pkg" "$visited_file" 2>/dev/null; then
    printf "%s%s (cycle)\n" "$prefix" "$pkg"
    return
  fi
  echo "$pkg" >> "$visited_file"
  # find direct deps
  local deps=()
  if [ -x "$DEPS_PY" ]; then
    # request JSON from deps.py
    mapfile -t deps < <("$DEPS_PY" graph-deps --pkg "$pkg" --json 2>/dev/null | python3 -c "import sys,json; d=json.load(sys.stdin) if not sys.stdin.isatty() else {}; print('\\n'.join(d.get('deps',[])))" 2>/dev/null || true)
  fi
  # fallback to metafile
  if [ "${#deps[@]}" -eq 0 ]; then
    local mf
    mf=$(find_metafile_for_pkg "$pkg" || true)
    if [ -n "$mf" ] && _have python3; then
      mapfile -t deps < <(python3 - <<PY
import yaml,sys
p=sys.argv[1]
try:
  d=yaml.safe_load(open(p,'r',encoding='utf-8')) or {}
except:
  d={}
deps=d.get('dependencies') or d.get('deps') or d.get('requires') or []
out=[]
if isinstance(deps, dict):
    for k in deps:
        v=deps.get(k) or []
        if isinstance(v, list): out+=v
elif isinstance(deps, list):
    out+=deps
elif isinstance(deps, str):
    out.append(deps)
for i in out:
    print(i)
PY
"$mf")
    fi
  fi
  # print ascii tree
  local i=0
  for d in "${deps[@]}"; do
    i=$((i+1))
    if [ $i -eq ${#deps[@]} ]; then
      printf "%s└─ %s\n" "$prefix" "$d"
      graph_ascii_recursive "$d" $((depth+1)) "${prefix}   " "$visited_file"
    else
      printf "%s├─ %s\n" "$prefix" "$d"
      graph_ascii_recursive "$d" $((depth+1)) "${prefix}│  " "$visited_file"
    fi
  done
}

cmd_graph(){
  local pkg="$1"
  if [ -z "$pkg" ]; then _die "Use: porg --graph <pkg>"; fi
  log_stage "Dependency graph for $pkg (ASCII)"
  # prepare visited file
  local vf="${STATE_DIR}/graph-${pkg}.$(_timestamp).visited"
  : > "$vf"
  printf "%s\n" "$pkg"
  graph_ascii_recursive "$pkg" 0 "" "$vf"
  rm -f "$vf"
}

# ------------------ Status, history, repair ------------------
cmd_status(){
  log_stage "System status summary"
  # number of installed packages via DB
  if [ -f "/var/lib/porg/db/installed.json" ] && command -v jq >/dev/null 2>&1; then
    local count
    count=$(jq 'length' /var/lib/porg/db/installed.json 2>/dev/null || echo 0)
    echo "Installed packages: $count"
  else
    echo "Installed DB not available"
  fi
  echo "State checkpoints: "
  ls -1 "$STATE_DIR"/*.state 2>/dev/null | sed -e 's#^.*/##' || true
  echo "Recent reports in $REPORT_DIR:"
  ls -1t "$REPORT_DIR"/*.{log,json} 2>/dev/null | head -n 10 || true
}

cmd_history(){
  log_stage "Showing recent build/install logs"
  ls -1t "$REPORT_DIR"/*.log 2>/dev/null | head -n 20 | xargs -r -n1 tail -n 200
}

cmd_repair(){
  log_stage "Repair: running resolve + audit"
  if [ -x "$RESOLVER" ]; then
    _call_module "$RESOLVER" --all --quiet || log_warn "Resolver returned non-zero"
  else
    log_warn "Resolver module not present"
  fi
  if [ -x "$AUDITOR" ]; then
    _call_module "$AUDITOR" --fix --quiet || log_warn "Auditor returned non-zero"
  else
    log_warn "Auditor not present"
  fi
}

# wrapper to call module with dry-run support
_call_module(){
  local module="$1"; shift
  if [ "${DRY_RUN:-false}" = true ]; then
    log_info "[DRY-RUN] Would call $module $*"
    return 0
  fi
  if [ -x "$module" ]; then
    "$module" "$@"
    return $?
  else
    log_warn "Module not executable: $module"
    return 2
  fi
}

# ------------------ Command dispatch ------------------
usage(){
  cat <<EOF
porg - orchestrator
Usage:
  porg --init
  porg --install <pkg>...
  porg --remove <pkg>...
  porg --upgrade [pkg...]
  porg --search <term>
  porg --info <pkg>
  porg --graph <pkg>
  porg --status
  porg --history
  porg --repair
  porg --resume <pkg>
  flags: --dry-run --yes --quiet --progress --parallel N --json
EOF
  exit 1
}

# parse top level global flags and command
DRY_RUN=false; AUTO_YES=false; QUIET=false; PROGRESS=false; PARALLEL_N=$(nproc 2>/dev/null || echo 1)
CMD=""; ARGS=()
while [ $# -gt 0 ]; do
  case "$1" in
    --dry-run) DRY_RUN=true; shift;;
    --yes) AUTO_YES=true; shift;;
    --quiet) QUIET=true; shift;;
    --progress) PROGRESS=true; shift;;
    --parallel) PARALLEL_N="${2:-$PARALLEL_N}"; shift 2;;
    --init|--install|--remove|--upgrade|--search|--info|--graph|--status|--history|--repair|--resume|--help)
      CMD="$1"; shift; ARGS=("$@"); break;;
    *) echo "Unknown option: $1"; usage;;
  esac
done

[ -n "$CMD" ] || usage

# Acquire lock
_acquire_lock

# Dispatch
case "$CMD" in
  --init)
    mkdir -p /etc/porg "$LIBDIR" "$PORTS_DIR" "$WORKDIR" "$LOGDIR" "$STATE_DIR" "/var/lib/porg/db"
    log_info "Initialized directories. Edit /etc/porg/porg.conf as needed."
    ;;

  --search)
    cmd_search "${ARGS[0]:-}"
    ;;

  --info)
    cmd_info "${ARGS[0]:-}"
    ;;

  --graph)
    cmd_graph "${ARGS[0]:-}"
    ;;

  --status)
    cmd_status
    ;;

  --history)
    cmd_history
    ;;

  --repair)
    cmd_repair
    ;;

  --resume)
    pkg="${ARGS[0]:-}"
    if [ -z "$pkg" ]; then _die "Use: porg --resume <pkg>"; fi
    st=$(load_state "$pkg")
    if [ "$st" = "{}" ]; then
      log_warn "No state found for $pkg"
      exit 1
    fi
    phase=$(echo "$st" | python3 -c "import sys,json; print(json.load(sys.stdin).get('phase',''))" 2>/dev/null || true)
    log_info "Resuming $pkg from phase: $phase"
    # simple resume behavior: call builder for the package (builder should handle repeated runs idempotently)
    if [ -x "$BUILDER" ]; then
      _call_module "$BUILDER" build "$pkg"
      clear_state "$pkg"
    else
      log_warn "Builder not found"
    fi
    ;;

  --install)
    if [ "${#ARGS[@]}" -eq 0 ]; then _die "Use: porg --install <pkg>..."; fi
    for pkg in "${ARGS[@]}"; do
      save_state "$pkg" "pre-resolve"
      if [ -x "$DEPS_PY" ]; then
        if [ "$DRY_RUN" = true ]; then
          log_info "[DRY-RUN] Would resolve deps for $pkg"
        else
          "$DEPS_PY" resolve "$pkg" || log_warn "deps.py resolve for $pkg returned non-zero"
        fi
      fi
      save_state "$pkg" "resolved"
      save_state "$pkg" "pre-build"
      # call builder: builder is expected to accept metafile name or package name
      if [ "$DRY_RUN" = false ]; then
        _call_module "$BUILDER" build "$pkg" || { log_warn "Build failed for $pkg"; continue; }
      else
        log_info "[DRY-RUN] Skipping actual build for $pkg"
      fi
      save_state "$pkg" "built"
      # install: builder usually installs to DESTDIR or packages; we try to register
      if [ -x "$DB_SCRIPT" ] && [ "$DRY_RUN" = false ]; then
        "$DB_SCRIPT" register "$pkg" || log_warn "DB register failed for $pkg"
      fi
      clear_state "$pkg"
    done
    ;;

  --remove)
    if [ "${#ARGS[@]}" -eq 0 ]; then _die "Use: porg --remove <pkg>..."; fi
    for pkg in "${ARGS[@]}"; do
      _call_module "$REMOVER" "$pkg" --yes
    done
    ;;

  --upgrade)
    # pass-through to upgrader
    _call_module "$UPGRADER" "$@"
    ;;

  --resolve)
    _call_module "$RESOLVER" --all
    ;;

  --audit)
    _call_module "$AUDITOR" --all
    ;;

  *)
    usage
    ;;
esac

_release_lock
exit 0
