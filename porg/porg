#!/usr/bin/env bash
#
# porg - Orquestrador principal do Porg
# Salve como /usr/bin/porg e torne executável: chmod +x /usr/bin/porg
#
# Funcionalidades:
#  - comandos: init, install (-i), remove (-r), upgrade (-u), resolve, audit, sync, db, logs, completion
#  - integra com: /etc/porg/porg.conf, porg_builder.sh, porg_remove.sh, porg_upgrade.sh, porg_resolve.sh, porg_audit.sh, porg_deps.py, porg_db.sh, porg_logger.sh
#  - UI: --progress (barra/contador), --quiet (resumo), spinner, monitor de load
#  - global flags: --dry-run, --yes, --parallel N, --json
#  - resume: grava estado simples em /var/lib/porg/state
#
set -euo pipefail
IFS=$'\n\t'

# --------------------------- Configuração inicial ---------------------------
PORG_CONF="${PORG_CONF:-/etc/porg/porg.conf}"
[ -f "$PORG_CONF" ] && source "$PORG_CONF"

# caminhos padrão (podem ser substituídos em porg.conf)
LIBDIR="${LIBDIR:-/usr/lib/porg}"
BUILDER="${BUILDER:-${LIBDIR}/porg_builder.sh}"
REMOVER="${REMOVER:-${LIBDIR}/porg_remove.sh}"
UPGRADER="${UPGRADER:-${LIBDIR}/porg_upgrade.sh}"
RESOLVER="${RESOLVER:-${LIBDIR}/porg_resolve.sh}"
AUDITOR="${AUDITOR:-${LIBDIR}/porg_audit.sh}"
DEPS_PY="${DEPS_PY:-${LIBDIR}/porg_deps.py}"
DB_SCRIPT="${DB_SCRIPT:-${LIBDIR}/porg_db.sh}"
LOGGER_SCRIPT="${LOGGER_SCRIPT:-${LIBDIR}/porg_logger.sh}"

WORKDIR="${WORKDIR:-/var/tmp/porg}"
LOGDIR="${LOGDIR:-/var/log/porg}"
REPORT_DIR="${REPORT_DIR:-${LOGDIR}}"
STATE_DIR="${STATE_DIR:-/var/lib/porg/state}"
PORTS_DIR="${PORTS_DIR:-/usr/ports}"

mkdir -p "$WORKDIR" "$LOGDIR" "$REPORT_DIR" "$STATE_DIR"

# --------------------------- Cores/UI ---------------------------
# use tput if available for portability; fallback to ANSI
if command -v tput >/dev/null 2>&1 && [ -t 1 ]; then
  C_RED="$(tput setaf 1)"
  C_GREEN="$(tput setaf 2)"
  C_YELLOW="$(tput setaf 3)"
  C_CYAN="$(tput setaf 6)"
  C_BOLD="$(tput bold)"
  C_RESET="$(tput sgr0)"
else
  C_RED="\e[31m"; C_GREEN="\e[32m"; C_YELLOW="\e[33m"; C_CYAN="\e[36m"; C_BOLD="\e[1m"; C_RESET="\e[0m"
fi

# --------------------------- Log wrapper (integra com porg_logger se houver) ---------------------------
if [ -f "$LOGGER_SCRIPT" ]; then
  # shellcheck disable=SC1090
  source "$LOGGER_SCRIPT" || true
else
  log_info(){ printf "%s %b[INFO]%b %s\n" "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "$C_GREEN" "$C_RESET" "$*"; }
  log_warn(){ printf "%s %b[WARN]%b %s\n" "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "$C_YELLOW" "$C_RESET" "$*"; }
  log_error(){ printf "%s %b[ERROR]%b %s\n" "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "$C_RED" "$C_RESET" "$*"; }
  log_stage(){ printf "%s %b[STAGE]%b %s\n" "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "$C_CYAN" "$C_RESET" "$*"; }
fi

# --------------------------- Helpers ---------------------------
_have(){ command -v "$1" >/dev/null 2>&1; }
_timestamp(){ date -u +%Y%m%dT%H%M%SZ; }
_die(){ log_error "$*"; exit 2; }

# spawn spinner for long ops (non-blocking)
SPINNER_PID=""
start_spinner(){
  local msg="${1:-working...}"
  if [ -t 1 ] && [ "${PROGRESS:-false}" = true ]; then
    ( while :; do for s in '/-\|'; do printf "\r%s %s" "$s" "$msg"; sleep 0.12; done; done ) &
    SPINNER_PID=$!
    disown
  fi
}
stop_spinner(){
  if [ -n "${SPINNER_PID:-}" ]; then
    kill "$SPINNER_PID" 2>/dev/null || true
    wait "$SPINNER_PID" 2>/dev/null || true
    unset SPINNER_PID
    printf "\r"
  fi
}

# monitor load/simple perf (background)
MON_PID=""
start_monitor(){
  local freq=${1:-2}
  if [ -t 1 ] && [ "${PROGRESS:-false}" = true ]; then
    ( while :; do
        read -r a b c d < /proc/loadavg || true
        memk=$(awk '/MemAvailable/ {print $2}' /proc/meminfo 2>/dev/null || echo 0)
        printf "\r[load: %s | mem_avail_kb: %s] " "$a" "$memk"
        sleep "$freq"
      done ) &
    MON_PID=$!
    disown
  fi
}
stop_monitor(){
  if [ -n "${MON_PID:-}" ]; then
    kill "$MON_PID" 2>/dev/null || true
    wait "$MON_PID" 2>/dev/null || true
    unset MON_PID
    printf "\r"
  fi
}

# progress bar simple (pct)
progress_bar(){
  local done=$1; local total=$2; local label="$3"
  local pct=0
  if [ "$total" -gt 0 ]; then pct=$(( done * 100 / total )); fi
  if [ -t 1 ] && [ "${PROGRESS:-false}" = true ]; then
    printf "\r[%d/%d] %s %d%%" "$done" "$total" "$label" "$pct"
  else
    printf "\r%s %s/%s" "$label" "$done" "$total"
  fi
}

# call module safely (handles dry-run, quiet)
_call_module(){
  local module_path="$1"; shift
  local args=("$@")
  if [ ! -x "$module_path" ]; then
    log_warn "Módulo não encontrado ou não executável: $module_path"
    return 2
  fi
  if [ "${DRY_RUN:-false}" = true ]; then
    log_info "[DRY-RUN] Would call: $module_path ${args[*]}"
    return 0
  fi
  "$module_path" "${args[@]}"
  return $?
}

# safe wrapper to run module inside bwrap if requested/available
_call_module_safe(){
  local module_path="$1"; shift
  local use_bwrap=${USE_BWRAP:-false}
  if [ "$use_bwrap" = true ] && _have bwrap; then
    # minimal bwrap call to isolate execution; pass through env variables
    bwrap --dev /dev --proc /proc --ro-bind /usr /usr --tmpfs /tmp --bind "$LIBDIR" "$LIBDIR" --die-with-parent "$module_path" "$@"
  else
    _call_module "$module_path" "$@"
  fi
}

# --------------------------- CLI ---------------------------
usage(){
  cat <<EOF
porg - Orquestrador Porg

Uso: porg <comando> [opções] [pacotes]

Comandos principais:
  --init                 Inicializa diretórios e arquivos necessários
  --install, -i <pkg>    Instala/compila e instala pacote (resolve deps, build, instala)
  --remove, -r <pkg>     Remove pacote (chama porg_remove.sh)
  --upgrade, -u [pkgs]   Executa upgrade (se vazio, usa --world)
  --resolve              Executa revdep+depclean (porg_resolve.sh)
  --audit                Executa auditoria (porg_audit.sh)
  --sync                 Sincroniza metafiles (git pull / sync)
  --db [subcmd]          Accesso a DB (wrap porg_db.sh)
  --logs                 Mostra os logs recentes
  --completion           Instala script de autocompletar bash
  --help                 Mostra esta ajuda

Flags globais:
  --dry-run              Simula as ações
  --yes                  Auto-confirma prompts
  --quiet                Saída compacta
  --progress             UI com barra/spinner
  --parallel N           Paralelismo (default: núcleos)
  --json                 Gera relatório JSON (quando aplicável)

Exemplos:
  porg -i gcc
  porg --upgrade --parallel 4
  porg --remove bash --yes
EOF
  exit 1
}

# --------------------------- Defaults e parsing simples de flags ---------------------------
DRY_RUN=false; AUTO_YES=false; QUIET=false; PROGRESS=false; PARALLEL_N=$(nproc 2>/dev/null || echo 1); JSON_OUT=false; USE_BWRAP=false

# parse top-level flags until command seen
if [ $# -eq 0 ]; then usage; fi
CMD=""; POSITIONAL=()
while [ $# -gt 0 ]; do
  case "$1" in
    --dry-run) DRY_RUN=true; shift;;
    --yes) AUTO_YES=true; shift;;
    --quiet) QUIET=true; shift;;
    --progress) PROGRESS=true; shift;;
    --parallel) PARALLEL_N="${2:-$PARALLEL_N}"; shift 2;;
    --json) JSON_OUT=true; shift;;
    --bwrap|--chroot) USE_BWRAP=true; shift;;
    --init|--install|-i|--remove|-r|--upgrade|-u|--resolve|--audit|--sync|--db|--logs|--completion|--help)
      CMD="$1"; shift
      POSITIONAL=("$@")
      break
      ;;
    *) echo "Opção desconhecida: $1"; usage;;
  esac
done

# normalize command aliases
case "$CMD" in
  -i) CMD="--install";;
  -r) CMD="--remove";;
  -u) CMD="--upgrade";;
esac

# --------------------------- Implementação dos comandos ---------------------------

# init: cria estrutura de diretórios padrão
cmd_init(){
  log_stage "Inicializando diretórios do Porg"
  mkdir -p /etc/porg "$LIBDIR" "$PORTS_DIR" "$WORKDIR" "$LOGDIR" "$STATE_DIR" "/var/lib/porg/db"
  # criar config default se não existir
  if [ ! -f /etc/porg/porg.conf ]; then
    cat > /etc/porg/porg.conf <<CONF
# porg.conf minimal (edit as needed)
LIBDIR="$LIBDIR"
WORKDIR="$WORKDIR"
LOGDIR="$LOGDIR"
STATE_DIR="$STATE_DIR"
PORTS_DIR="$PORTS_DIR"
CONF
    log_info "Arquivo de configuração criado: /etc/porg/porg.conf (edite conforme necessário)"
  else
    log_info "Arquivo de configuração existente: /etc/porg/porg.conf"
  fi
  # autocomplete
  cmd_completion_install >/dev/null 2>&1 || true
  log_info "Inicialização concluída."
}

# autocompletion installer
cmd_completion_install(){
  local dest="/etc/bash_completion.d/porg"
  cat > "$dest" <<'BASHCOMP'
_porg_complete(){
  local cur opts
  cur="${COMP_WORDS[COMP_CWORD]}"
  opts="--init --install --remove --upgrade --resolve --audit --sync --db --logs --completion --help --dry-run --yes --quiet --progress --parallel --json"
  COMPREPLY=( $(compgen -W "$opts" -- "$cur") )
}
complete -F _porg_complete porg
BASHCOMP
  log_info "Autocompletar instalado em $dest"
}

# wrapper para construir/instalar pacote (install)
cmd_install(){
  if [ "${#POSITIONAL[@]}" -lt 1 ]; then _die "Use: porg --install <pkg>"; fi
  local pkgs=("${POSITIONAL[@]}")
  log_stage "Orquestrando instalação: ${pkgs[*]}"
  # chamar deps resolver antes de build (se existir)
  if [ -x "$DEPS_PY" ]; then
    log_info "Resolvendo dependências (via porg_deps.py)"
    if [ "$DRY_RUN" = true ]; then
      log_info "[DRY-RUN] deps.py resolve ${pkgs[*]}"
    else
      "$DEPS_PY" resolve "${pkgs[@]}" || log_warn "deps.py retornou não-zero"
    fi
  fi

  # se paralel >1, rodar builds em paralelo; chamamos builder para cada pacote
  local total=${#pkgs[@]}; local i=0
  start_monitor; start_spinner "Construindo pacotes..."
  for pkg in "${pkgs[@]}"; do
    i=$((i+1))
    progress_bar "$i" "$total" "install $pkg"
    log_info "Invocando builder para $pkg"
    if [ "$PARALLEL_N" -gt 1 ]; then
      # run concurrent respecting PARALLEL_N: spawn background and throttle
      ( _call_module "$BUILDER" build "$pkg" ) &
      # throttle:
      while [ "$(jobs -rp | wc -l)" -ge "$PARALLEL_N" ]; do sleep 0.2; done
    else
      _call_module "$BUILDER" build "$pkg"
    fi
  done
  wait
  stop_spinner; stop_monitor
  log_stage "Instalação finalizada"
  # pós-instalar: executar audit rápido
  if [ -x "$AUDITOR" ]; then
    if [ "$DRY_RUN" = false ]; then
      log_info "Executando auditoria rápida pós-instalação"
      _call_module "$AUDITOR" --quick --quiet || log_warn "Auditor returned non-zero"
    fi
  fi
}

# remove wrapper
cmd_remove(){
  if [ "${#POSITIONAL[@]}" -lt 1 ]; then _die "Use: porg --remove <pkg>"; fi
  local pkgs=("${POSITIONAL[@]}")
  log_stage "Orquestrando remoção: ${pkgs[*]}"
  start_spinner "Removendo..."
  if [ "$PARALLEL_N" -gt 1 ]; then
    # parallel removals: spawn background processes that call remover script
    for pkg in "${pkgs[@]}"; do
      ( _call_module "$REMOVER" "$pkg" --yes --quiet ) &
      while [ "$(jobs -rp | wc -l)" -ge "$PARALLEL_N" ]; do sleep 0.2; done
    done
    wait
  else
    for pkg in "${pkgs[@]}"; do
      _call_module "$REMOVER" "$pkg" --yes --quiet
    done
  fi
  stop_spinner
  log_stage "Remoção finalizada"
  # audit pós-removal
  if [ -x "$AUDITOR" ]; then
    log_info "Executando auditoria pós-removal"
    _call_module "$AUDITOR" --quick --quiet || log_warn "Auditor returned non-zero"
  fi
}

# upgrade wrapper - usa upgrader module
cmd_upgrade(){
  # if positional empty => world
  if [ "${#POSITIONAL[@]}" -eq 0 ]; then
    log_info "Executando upgrade do world (porg_upgrade.sh)"
    _call_module "$UPGRADER" --progress --parallel "$PARALLEL_N" || log_warn "Upgrade world retornou não-zero"
    return
  fi
  log_info "Executando upgrade para pacotes: ${POSITIONAL[*]}"
  _call_module "$UPGRADER" --pkgs "${POSITIONAL[@]}" --progress --parallel "$PARALLEL_N" || log_warn "Upgrade retornou não-zero"
}

# resolve wrapper
cmd_resolve(){
  log_stage "Executando resolver (revdep+depclean)"
  _call_module "$RESOLVER" --all --quiet || log_warn "Resolver retornou não-zero"
}

# audit wrapper
cmd_audit(){
  log_stage "Executando auditoria completa"
  _call_module "$AUDITOR" --all --quiet || log_warn "Audit retornou não-zero"
}

# sync wrapper (sincroniza metafiles com repo git se existir)
cmd_sync(){
  log_stage "Sincronizando metafiles (git) e /usr/ports"
  # check for ports repo configured in config or default; a sync method could be custom; here do simple git pull on PORTS_DIR if .git exists
  if [ -d "${PORTS_DIR}/.git" ]; then
    if [ "$DRY_RUN" = true ]; then
      log_info "[DRY-RUN] git -C $PORTS_DIR pull --ff-only"
    else
      git -C "$PORTS_DIR" pull --ff-only || log_warn "git pull em $PORTS_DIR falhou"
    fi
  else
    log_info "No git repo em $PORTS_DIR; deixe seu repositório de metafiles em $PORTS_DIR/.git para sync"
  fi
  # opcional: também puxar de DEPS_PY remote se necessário (deps.py tem método de sync)
  if [ -x "$DEPS_PY" ]; then
    if [ "$DRY_RUN" = true ]; then
      log_info "[DRY-RUN] $DEPS_PY sync"
    else
      "$DEPS_PY" sync || log_warn "deps.py sync returned non-zero"
    fi
  fi
}

# db wrapper
cmd_db(){
  if [ ! -x "$DB_SCRIPT" ]; then _die "DB module não encontrado: $DB_SCRIPT"; fi
  if [ "${#POSITIONAL[@]}" -eq 0 ]; then
    $DB_SCRIPT status
  else
    $DB_SCRIPT "${POSITIONAL[@]}"
  fi
}

# logs wrapper (exibe últimos logs)
cmd_logs(){
  local n="${POSITIONAL[0]:-30}"
  log_stage "Mostrando últimos $n logs (texto)"
  ls -1t "${LOGDIR}"/*.log 2>/dev/null | head -n "$n" | xargs -r -n1 tail -n 200
}

# completion installer
cmd_completion(){
  cmd_completion_install
}

# help
cmd_help(){ usage; }

# --------------------------- Dispatcher ---------------------------
case "$CMD" in
  --init) cmd_init;;
  --install) cmd_install;;
  --remove) cmd_remove;;
  --upgrade) cmd_upgrade;;
  --resolve) cmd_resolve;;
  --audit) cmd_audit;;
  --sync) cmd_sync;;
  --db) cmd_db;;
  --logs) cmd_logs;;
  --completion) cmd_completion;;
  --help) cmd_help;;
  *) usage;;
esac

exit 0
